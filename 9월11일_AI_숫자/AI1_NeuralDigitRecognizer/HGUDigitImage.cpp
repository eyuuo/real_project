/***
	Copyright 2017 Injung Kim

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
//9.11
***/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "HGUDigitImage.h"

HGUDigitImage::HGUDigitImage()//constructor 컨스트럭터.
{
	memset(vector, 0, DigitSize * sizeof(vector[0]));
	//0으로 다 초기화 시켜라.
}

void HGUDigitImage::Clear(float v)
{
	for (int i = 0; i < DigitSize; i++)
		vector[i] = v;
}

void HGUDigitImage::SetDigit(int d)
{ //벡터를 아래 숫자로 35차원짜리 벡터를 채워라.
	static float digit[10][DigitSize] = {
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000 },
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000 },
		{ 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000 },
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 },
		{ 0.000000, 1.000000, 1.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.000000 }
	};

	if (d < 0 || d > 9){
		printf("Invalid argument in %s (%s %d). d = %d\n", __FUNCTION__, __FILE__, __LINE__, d);
		return;
	}

	memcpy(vector, digit[d], DigitSize * sizeof(vector[0]));
	//위에 중 하나를 여기로 복사하고 싶을때....
}

void HGUDigitImage::SetImage(float *src)
{
	memcpy(vector, src, DigitSize * sizeof(vector[0]));
}

void HGUDigitImage::AddNoise(float flipProb) //파라미터를 0.2로 하면...&//
{ //현재 벡터라는 위치에 특정한 shape가 이다. 일정한 노이즈를 넣을 려고 하는데 
	for(int i = 0; i < DigitSize; i++){
		int r = rand();//랜덤
		if(r / (float)RAND_MAX < flipProb)//&//확률에 비추어서 뒤집어라
			vector[i] = 1.F - vector[i];//흰색은 검, 검은 색은 흰.
	}
}

void HGUDigitImage::Display()
{
	int idx = 0;
	for (int y = 0; y < DigitHeight; y++){
		for (int x = 0; x < DigitWidth; x++){
//			printf("%4.2f ", vector[idx++]) /0이나 ,이 아닌 숫자 자체를 출력하는. 디버그용.
			printf("%c ", (vector[idx++] >= 0.5f ? 'O' : '.'));//0을 출력할지 ,을 출력할지
		}
		printf("\n");
	}
}

HGUDigitImage& HGUDigitImage::operator=(const HGUDigitImage &src)
{
	memcpy(vector, src.vector, DigitSize * sizeof(vector[0]));
	return *this;
}

void HGUDigitImage::DisplayAsArray()
{
	printf("{ ");

	for (int i = 0; i < DigitSize; i++){
		if(i < DigitSize - 1)
			printf("%f, ", vector[i]);
		else
			printf("%f", vector[i]);
	}

	printf(" };");
}
